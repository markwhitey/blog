<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[谈谈精酿啤酒]]></title>
    <url>%2F2019%2F07%2F15%2F%E8%B0%88%E8%B0%88%E7%B2%BE%E9%85%BF%E5%95%A4%E9%85%92%2F</url>
    <content type="text"><![CDATA[How to dispel melancholy, only has Dukang liquor 概念 目前比较官方的定义是： 年产量小于600万桶（70.2万吨），用于商业交易； 非精酿酿造者或公司机构，其占股份不能超过25%； 酿造者所酿造的大部分啤酒的风味，应从传统或者创新原料与发酵工艺中获得。 简单来说就是，精酿啤酒是区别于工业啤酒的一种概念： 水啤的特点：颜色很浅，泡沫稍纵即逝，味道寡淡； 精酿啤酒：颜色多样，泡沫丰富，风味多样，饮用方式讲究仪式感。 分类 至于生啤、熟啤、扎啤、冰啤： 生啤：啤酒里有活酵母的啤酒，喝起来感觉更新鲜； 熟啤：经过高温消毒，酵母都死翘翘了； 扎啤：把啤酒灌进不锈钢桶里，最大程度还原啤酒刚刚出厂的味道； 冰啤：过滤的时候瞬间把温度降到0℃左右，让杂质析出，这样过滤出来的啤酒非常清澈，但味道也十分寡淡。 精酿的分类方式一:发酵工艺 艾尔 Ale，也称上层发酵啤酒 ​ 我们喝的大部分精酿属于艾尔啤酒，艾尔啤酒的酵母在发酵时会集中在酒桶的上方，所以又称“上层发酵啤酒”。它发酵所需温度较高（18-23℃），酵母在这个温度下能产生更多风味物质，如：坚果、西柚、香蕉、辛香……同时也会产生更多酒精。 ​ 所以艾尔啤酒的味道更加丰富、醇厚、风格更加多变，酒精度数普遍更高（5-10%酒精度是家常便饭）。 拉格Lager，也称下层发酵啤酒 ​ “工业啤酒”就是典型的拉格啤酒，与艾尔相反，拉格的酵母在酒桶底起作用，所以又称“底层发酵”。拉格啤酒发酵所需温度较低（4-10℃），酵母产生的风味物质更少，再加上酿造者会加入大量辅料（大米、玉米……）以降低成本。 ​ 以至于拉格啤酒风味较寡淡，口感更清爽，酒精度更低。（一般工业啤酒酒精度在3%左右，比起5-10%酒精度的艾尔啤酒，简直小巫见大巫）。 ​ 所以拉格极其讲究做工，若是味道有一点瑕疵就会暴露。但是！敲黑板！拉格绝对不是劣质啤酒的代名词，市面上依然有很多高品质的拉格啤酒。 精酿啤酒的分类方式二：产地 全球有 4 个地方的精酿比较有代表性，他们分别是：比利时、英国、德国、美国。当然，像新西兰、日本等地也有自己的特色，但是不具备普遍性和代表性，因此这里暂时以4个有代表性的地区来分类。 比利时 ​ 比利时是个不折不扣的啤酒大国，虽然面积不大，但啤酒产量遥遥领先。而且啤酒历史悠久，品质高，其中修道院啤酒最具有代表性。 ​ 比利时的啤酒种类非常多，浓度、颜色、风味、辅料……都千差万别，但总结来说，其共同点是：苦味较低，香味浓郁，风味多变且平衡。 英国 ​ 很久以前，英国啤酒课税标准是麦汁浓度的高低，麦汁浓度越高，税越高，所以英国人民为了利润最大化，广推酿度数较低的啤酒（3-6% 酒精度）。另外，英国的啤酒更加突出麦芽的味道，例如：烤面包、咖啡、巧克力、焦糖……。 德国 ​ 一说到德国啤酒，估摸着你第一反应到了「德国黑啤」。其实这里「德国黑啤」大多属于「欧洲深色拉格」，除了这种风格外，德国还有很多经典啤酒等你发掘。 ​ 德国啤酒更注重麦芽与酒花的平衡，而且会突出德国酵母的香味（如丁香、香蕉味），而且普遍度数较低，适合大口畅饮。]]></content>
      <categories>
        <category>生活</category>
        <category>精酿啤酒</category>
      </categories>
      <tags>
        <tag>精酿啤酒</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈servlet]]></title>
    <url>%2F2019%2F07%2F14%2F%E8%B0%88%E8%B0%88servlet%2F</url>
    <content type="text"><![CDATA[servlet生命周期➕get方式和post方式的区别➕forward和redirect的区别➕Session和cookie有什么区别➕jsp和servlet的区别、共同点、各自应用的范围➕属性作用域 servlet生命周期 Servlet生命周期可分为5个步骤: 加载Servlet。当Tomcat第一次访问Servlet的时候，Tomcat会负责创建Servlet的实例 初始化。当Servlet被实例化后，Tomcat会调用init()方法初始化这个对象 处理服务。当浏览器访问Servlet的时候，Servlet 会调用service()方法处理请求 销毁。当Tomcat关闭时或者检测到Servlet要从Tomcat删除的时候会自动调用destroy()方法，让该实例释放掉所占的资源。一个Servlet如果长时间不被使用的话，也会被Tomcat自动销毁 卸载。当Servlet调用完destroy()方法后，等待垃圾回收。如果有需要再次使用这个Servlet，会重新调用init()方法进行初始化操作。 总结 只要访问Servlet，service()就会被调用。init()只有第一次访问Servlet的时候才会被调用。destroy()只有在Tomcat关闭的时候才会被调用。 get方式和post方式的区别 数据携带 GET方式：在URL地址后附带的参数是有限制的，其数据容量通常不能超过1K。 POST方式：可以在请求的实体内容中向服务器发送数据，传送的数据量无限制。 请求参数的位置 GET方式：请求参数放在URL地址后面，以?的方式来进行拼接 POST方式:请求参数放在HTTP请求包中 用途 GET方式一般用来获取数据 POST方式一般用来提交数据 原因: 首先是因为GET方式携带的数据量比较小，无法带过去很大的数量 POST方式提交的参数后台更加容易解析(使用POST方式提交的中文数据，后台也更加容易解决) GET方式比POST方式要快 forward和redirect的区别 实际发生位置不同，地址栏不同 转发是发生在服务器的 转发是由服务器进行跳转的，细心的朋友会发现，在转发的时候，浏览器的地址栏是没有发生变化的，在我访问Servlet111的时候，即使跳转到了Servlet222的页面，浏览器的地址还是Servlet111的。也就是说浏览器是不知道该跳转的动作，转发是对浏览器透明的。通过上面的转发时序图我们也可以发现，实现转发只是一次的http请求，一次转发中request和response对象都是同一个。这也解释了，为什么可以使用request作为域对象进行Servlet之间的通讯。 重定向是发生在浏览器的 重定向是由浏览器进行跳转的，进行重定向跳转的时候，浏览器的地址会发生变化的。曾经介绍过：实现重定向的原理是由response的状态码和Location头组合而实现的。这是由浏览器进行的页面跳转实现重定向会发出两个http请求，request域对象是无效的，因为它不是同一个request对象 用法不同: 很多人都搞不清楚转发和重定向的时候，资源地址究竟怎么写。有的时候要把应用名写上，有的时候不用把应用名写上。很容易把人搞晕。记住一个原则： 给服务器用的直接从资源名开始写，给浏览器用的要把应用名写上 request.getRequestDispatcher(&quot;/资源名 URI&quot;).forward(request,response) 转发时&quot;/&quot;代表的是本应用程序的根目录【zhongfucheng】 response.send(&quot;/web应用/资源名 URI&quot;); 重定向时&quot;/&quot;代表的是webapps目录 能够去往的URL的范围不一样: 转发是服务器跳转只能去往当前web应用的资源 重定向是服务器跳转，可以去往任何的资源 传递数据的类型不同 转发的request对象可以传递各种类型的数据，包括对象 重定向只能传递字符串 跳转的时间不同 转发时：执行到跳转语句时就会立刻跳转 重定向：整个页面执行完之后才执行跳转 那么转发(forward)和重定向(redirect)使用哪一个？ 根据上面说明了转发和重定向的区别也可以很容易概括出来**。转发是带着转发前的请求的参数的。重定向是新的请求**。 典型的应用场景： 转发: 访问 Servlet 处理业务逻辑，然后 forward 到 jsp 显示处理结果，浏览器里 URL 不变 重定向: 提交表单，处理成功后 redirect 到另一个 jsp，防止表单重复提交，浏览器里 URL 变了 Session和cookie有什么区别？ 从存储方式上比较 Cookie只能存储字符串，如果要存储非ASCII字符串还要对其编码。 Session可以存储任何类型的数据，可以把Session看成是一个容器 从隐私安全上比较 Cookie存储在浏览器中，对客户端是可见的。信息容易泄露出去。如果使用Cookie，最好将Cookie加密 Session存储在服务器上，对客户端是透明的。不存在敏感信息泄露问题。 从有效期上比较 Cookie保存在硬盘中，只需要设置maxAge属性为比较大的正整数，即使关闭浏览器，Cookie还是存在的 Session的保存在服务器中，设置maxInactiveInterval属性值来确定Session的有效期。并且Session依赖于名为JSESSIONID的Cookie，该Cookie默认的maxAge属性为-1。如果关闭了浏览器，该Session虽然没有从服务器中消亡，但也就失效了。 从对服务器的负担比较 Session是保存在服务器的，每个用户都会产生一个Session，如果是并发访问的用户非常多，是不能使用Session的，Session会消耗大量的内存。 Cookie是保存在客户端的。不占用服务器的资源。像baidu、Sina这样的大型网站，一般都是使用Cookie来进行会话跟踪。 从浏览器的支持上比较 如果浏览器禁用了Cookie，那么Cookie是无用的了！ 如果浏览器禁用了Cookie，Session可以通过URL地址重写来进行会话跟踪。 从跨域名上比较 Cookie可以设置domain属性来实现跨域名 Session只在当前的域名内有效，不可夸域名 jsp和servlet的区别、共同点、各自应用的范围 JSP是Servlet技术的扩展，本质上就是Servlet的简易方式。JSP编译后是“类servlet”。 Servlet和JSP最主要的不同点在于：Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML里分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。 JSP侧重于视图，Servlet主要用于控制逻辑。 属性作用域范围 属性作用域 page【只在一个页面中保存属性，跳转页面无效】 requet【只在一次请求中保存属性，服务器跳转有效，浏览器跳转无效】 session【在一个会话范围中保存属性，无论何种跳转均有效，关闭浏览器后无效】 application/servletcontext【在整个服务器中保存，所有用户都可以使用】 应用场景 request：如果客户向服务器发请求，产生的数据，**用户看完就没用了，**像这样的数据就存在request域,像新闻数据，属于用户看完就没用的 session：如果客户向服务器发请求，产生的数据，用户用完了等一会儿还有用，像这样的数据就存在session域中，像购物数据，用户需要看到自己购物信息，并且等一会儿，还要用这个购物数据结帐 application/servletContext：如果客户向服务器发请求，产生的数据，用户用完了，还要给其它用户用，像这样的数据就存在servletContext域中，像聊天数据]]></content>
      <categories>
        <category>Java</category>
        <category>Web</category>
        <category>servlet</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Java</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java辨析题二]]></title>
    <url>%2F2019%2F07%2F14%2FJava%E8%BE%A8%E6%9E%90%E9%A2%98%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[面向对象和面向过程的区别➕Java和c++的区别➕构造器constructor是否可以被override➕hashcode与equals 面向对象和面向过程的区别 面向过程 优点:性能比面向对象高,因为类调用时需要实例化,开销比较大,比较消耗资源.比如单片机,嵌入式开发,linux/unix等一般采用面向过程开发,性能是最重要的因素 缺点:没有面向对象易维护,易复用,易拓展 面向对象 优点:易维护,易复用,易拓展,由于面向对象有封装,继承,多态的特性,可以设计出低耦合的系统,使系统更加灵活,更加易于维护 缺点:性能比面向对象低 Java和c++的区别 都是面向对象的语言,都支持封装,继承,多态 Java不提供指针访问内存,程序内存更加安全 Java类只支持单继承,c++支持多继承,但是Java可以实现多个接口 Java有自动释放内存管理机制,不需要手动释放内存 构造器constructor是否可以被override 父类的私有属性和构造方法不能被继承,所以说constructor不能被override,但是可以overload,所以一个类中有多个构造方法 hashcode与equals 你重写过hashcode和equals吗.为什么重写equals是必须重写hashcode? hashcode()介绍 hashcode()的作用是获取哈希码,他实际上是方茴一个int整数.这个哈希码的作用是确定该对象在哈希表的索引位置.hashcode定义在jdk的object.java中,这意味着在java的任何类中都有hashcode()函数. 哈希表存储的是键值对,他的特点是能根据&quot;键&quot;快速的检索出对应的值,这其中就利用了哈希码 为什么要有hashcode 我们以&quot;hashcode如何检查重复&quot;为例,说明为什么要用hashcode 当你把对象加入hashset时,hashset会计算对象的hashcode值来判断对象加入的位置,同时也会与其他已经加入的对象的hashcode值做对比,如果没有相符的hashcode,hashset会假设对象没有重复出现,如果发现有相同的hashcode值的对象,这时会调用equals()方法来检查hashcode对象是否真的相同.如果两者相同,hashset就不会让其加入操作成功.如果不同的话,就会重新散列到其他位置,这样的话会减少equals的次数,也就相应的提高了执行速度. hashcode()和equals的相关规定 如果两个对象相等,则hashcode也一定相同 两个对象相等,对两个对象调用equals的方法都返回true 两个对象有相同的hashcode值,它们也不一定相等 equals方法被覆盖,则hashcode方法也必须被覆盖 hashcode的默认行为是对堆上的对象产生独特值,如果没有重写hashcode,则该class文件中的两个对象无论如何都不会相等(即使两个对象指向同一个数据)]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>hashcode</tag>
        <tag>equals</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CDN加速]]></title>
    <url>%2F2019%2F07%2F14%2FCDN%E5%8A%A0%E9%80%9F%2F</url>
    <content type="text"><![CDATA[内容分发网络（英语：Content Delivery Network或Content Distribution Network，缩写：CDN）是指一种透过互联网互相连接的计算机网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、影片、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。 优点 内容分发网络的总承载量可以比单一骨干最大的带宽还要大。这使得内容分发网络可以承载的用户数量比起传统单一服务器多。也就是说，若把有100Gbps处理能力的服务器放在只有10Gbps带宽的数据中心，则亦只能发挥出10Gbps的承载量。但如果放到十个有10Gbps的地点，整个系统的承载量就可以到10×10Gbps。同时，将服务器放到不同地点，可以减少互连的流量，进而降低带宽成本。 对于TCP传输而言，TCP的速度（throughput）会受到延迟时间（latency）与数据包漏失率（packet loss）影响。为了改善这些负面因素，内容分发网络通常会指派较近、较顺畅的服务器节点将数据传输给用户。虽然距离并不是绝对因素，但这么做可以尽可能提高性能，用户将会觉得比较顺畅。这使得一些比较高带宽的应用（传输高清画质的影片）更容易推动。 内容分发网络另外一个好处在于有异地备援。当某个服务器故障时，系统将会调用其他邻近地区的服务器服务，进而提供接近100%的可靠度。 除此之外，内容分发网络提供给服务提供者更多的控制权。提供服务的人可以针对客户、地区，或是其他因子调整。 公用开源cdn哪家强? 我们所有的主题渲染highlight.js以及数学公式katex.js都是都可以在jsdelivr上找到,而且也非常推荐使用此公共cdn,对中国有加速，支持npm,github ,WordPress包，完全免费无限制，全球都很快。 代码主题渲染 访问其官方网站highlight.js进行探索 操作步骤: 只需要把以下代码放在你的博客源码的head中,他会自动寻找&lt;\pre&gt;&lt;\code&gt;中的代码并且去渲染 1234&lt;link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.15.8/build/styles/default.min.css"&gt;&lt;script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.15.8/build/highlight.min.js"&gt;&lt;/script&gt;&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt; 如果你不喜欢默认的主题,你可以把代码中的default关键字替换成你喜欢的主题的名字,所有主题你都可以在官网上查看渲染不同语音的不同主题效果,如图所示: ![](file://C:/Users/Administrator/Desktop/googlesync/Gridea/post-images/1561820901909.png) 此处写一下我在操作遇到的坑: 直接在官网上找链接,不要使用jsdelivr网站上的npm方式的链接方式(很气愤😤,不知道为什么渲染不成功,搞了好长时间) 一定要看自己的博客有么有&lt;\pre&gt;,如果没有需要自己设置 渲染效果 12345678910111213141516/** * @author John Smith &lt;john.smith@example.com&gt;*/package l2f.gameserver.model;public abstract class L2Char extends L2Object &#123; public static final Short ERROR = 0x0001; public void moveTo(int x, int y, int z) &#123; _ai = null; log("Should not be called"); if (1 &gt; 5) &#123; // wtf!? return; &#125; &#125;&#125; 数学公式 操作步骤: 访问其官网katex可自行探索 ,数学公式的渲染如同代码主题的渲染操作,复制以下代码添加到head中: 1234&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous"&gt;&lt;script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js" integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ" crossorigin="anonymous"&gt;&lt;/script&gt;&lt;script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body);"&gt;&lt;/script&gt; 此代码不会在页面加载时就开始渲染,而是出现关键符号是才会加载,所以不会影响页面加载速度 在写公式的时候按照markdown格式处理你要显示的数学公式即可. 转换效果 转换前: 123f&#123;x&#125; = \int_&#123;-\infty&#125;^\infty\hat f(\xi),e^&#123;2 \pi i \xi x&#125;\,d\xi 转换后: fx=∫−∞∞f^(ξ),e2πiξx dξf{x} = \int_{-\infty}^\infty \hat f(\xi),e^{2 \pi i \xi x} \,d\xi fx=∫−∞∞​f^​(ξ),e2πiξxdξ 还是要学好基础啊,走了许多弯路]]></content>
      <categories>
        <category>Java</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>cdn加速</tag>
        <tag>katex</tag>
        <tag>数学公式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[listener与filter]]></title>
    <url>%2F2019%2F07%2F14%2Flistener%E4%B8%8Efilter%2F</url>
    <content type="text"><![CDATA[Filter是一个可重复使用的代码片段，可以用来转换HTTP请求、响应和头信息。Filter不像Servlet，它不能产生一个请求或者响应，它只是修改对某一资源的请求，或者修改从某一资源的响应。 Listener是监听器，通过Listener可以监听Web服务器中某一个执行动作，并根据其要求作出相应的响应。通俗的来说就是在Application，Session，Request三个对象创建、消亡或者往其中添加、修改、删除属性时自动执行代码功能的组件。 监听器有哪些作用和用法 Java Web开发中的监听器（listener）就是application、session、request三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件，如下所示： ServletContextListener：对Servlet上下文的创建和销毁进行监听。 ServletContextAttributeListener：监听Servlet上下文属性的添加、删除和替换。 HttpSessionListener：对Session的创建和销毁进行监听。 补 充：session的销毁有两种情况： session超时（可以在web.xml中通过&lt;session- config&gt;/&lt;session-timeout&gt;标签配置超时时间）； 通过调用session对象的invalidate()方 法使session失效。 HttpSessionAttributeListener：对Session对象中属性的添加、删除和替换进行监听。 ServletRequestListener：对请求对象的初始化和销毁进行监听。 ServletRequestAttributeListener：对请求对象属性的添加、删除和替换进行监听。 常见的监听器用途主要包括：网站在线人数技术、监听用户的行为(管理员踢人)。 监听器的用法 ServletContextListener:监听ServletContext对象的创建和销毁 方法： void contextDestroyed(ServletContextEvent sce) ：ServletContext对象被销毁之前会调用该方法 void contextInitialized(ServletContextEvent sce) ：ServletContext对象创建后会调用该方法 步骤： 定义一个类，实现ServletContextListener接口 复写方法 配置 web.xml 注解配置@WebListener 12345&lt;listener&gt;&lt;listener-class&gt;cn.listener.ContextLoaderListener&lt;/listener-class&lt;/listener&gt; 过滤器的作用 Java Web开发中的过滤器（filter）是从Servlet 2.3规范开始增加的功能，并在Servlet 2.4规范中得到增强。对Web应用来说，过滤器是一个驻留在服务器端的Web组件，它可以截取客户端和服务器之间的请求与响应信息，并对这些信息进行过 滤。当Web容器接受到一个对资源的请求时，它将判断是否有过滤器与这个资源相关联。如果有，那么容器将把请求交给过滤器进行处理。在过滤器中，你可以改 变请求的内容，或者重新设置请求的报头信息，然后再将请求发送给目标资源。当目标资源对请求作出响应时候，容器同样会将响应先转发给过滤器，再过滤器中， 你可以对响应的内容进行转换，然后再将响应发送到客户端。 常见的过滤器用途主要包括：对用户请求进行统一认证、对用户的访问请求进行记录和审核、对用户发送的数据进行过滤或替换、转换图象格式、对响应内容进行压缩以减少传输量、对请求或响应进行加解密处理、触发资源访问事件、对XML的输出应用XSLT等。 和过滤器相关的接口主要有：Filter、FilterConfig、FilterChain 过滤器使用方法 步骤： 定义一个类，实现接口Filter 复写方法 配置拦截路径 web.xml 注解 代码： 12345678910111213141516171819202122@WebFilter("/*")//访问所有资源之前，都会执行该过滤器public class FilterDemo1 implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println("filterDemo1被执行了...."); //放行 filterChain.doFilter(servletRequest,servletResponse); &#125; @Override public void destroy() &#123; &#125;&#125; 过滤器细节 web.xml配置 123456789&lt;filter&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;filter-class&gt;web.filter.FilterDemo1&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;!-- 拦截路径 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 过滤器执行流程 执行过滤器 执行放行后的资源 回来执行过滤器放行代码下边的代码 过滤器生命周期方法 init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源 doFilter:每一次请求被拦截资源时，会执行。执行多次 destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源 过滤器配置详解 拦截路径配置： 具体资源路径： /index.jsp 只有访问index.jsp资源时，过滤器才会被执行 拦截目录： /user/* 访问/user下的所有资源时，过滤器都会被执行 后缀名拦截： *.jsp 访问所有后缀名为jsp资源时，过滤器都会被执行 拦截所有资源：/** 访问所有资源时，过滤器都会被执行 拦截方式配置：资源被访问的方式 注解配置： 设置dispatcherTypes属性 REQUEST：默认值。浏览器直接请求资源 FORWARD：转发访问资源 INCLUDE：包含访问资源 ERROR：错误跳转资源 ASYNC：异步访问资源 web.xml配置 设置标签即可 过滤器链(配置多个过滤器) 执行顺序：如果有两个过滤器：过滤器1和过滤器2 过滤器1 过滤器2 资源执行 过滤器2 过滤器1 过滤器先后顺序问题： 注解配置：按照类名的字符串比较规则比较，值小的先执行 如： AFilter 和 BFilter，AFilter就先执行了。 web.xml配置： 谁定义在上边，谁先执行]]></content>
      <categories>
        <category>Java</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>servlet</tag>
        <tag>listener</tag>
        <tag>filter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于666的高级方程式解法]]></title>
    <url>%2F2019%2F07%2F14%2F%E5%85%B3%E4%BA%8E666%E7%9A%84%E9%AB%98%E7%BA%A7%E6%96%B9%E7%A8%8B%E5%BC%8F%E8%A7%A3%E6%B3%95%2F</url>
    <content type="text"><![CDATA[lim⁡x→+∞−∫0xln⁡t(t2+1)(t3+1)dt(∫0x∣sin⁡t∣dt)2exp⁡(3∑k=0x1x+k)x5Li5(1x)−x4−132x3\lim _{x \rightarrow+\infty}-\frac{\int_{0}^{x} \frac{\ln t}{\left(t^{2}+1\right)\left(t^{3}+1\right)} d t\left(\int_{0}^{x}|\sin t| d t\right)^{2} \exp \left(3 \sum_{k=0}^{x} \frac{1}{x+k}\right)}{x^{5} L i_{5}\left(\frac{1}{x}\right)-x^{4}-\frac{1}{32} x^{3}} x→+∞lim​−x5Li5​(x1​)−x4−321​x3∫0x​(t2+1)(t3+1)lnt​dt(∫0x​∣sint∣dt)2exp(3∑k=0x​x+k1​)​ 详细解法 第一部分 ∫0∞ln⁡x(1+x2)(1+x3)dx=∫0∞ln⁡x(1+x2)(1+x3)dx−∫01x3ln⁡x(1+x2)(1+x3)dx=∫0(x+1(x2+1)−x2(x3+1))ln⁡xdx−∫0(1−x(x2+1)−x2−1(x3+1))ln⁡xdx=37π2432\begin{array}{l}{\int_{0}^{\infty} \frac{\ln x}{\left(1+x^{2}\right)\left(1+x^{3}\right)} d x} \\ {=\int_{0}^{\infty} \frac{\ln x}{\left(1+x^{2}\right)\left(1+x^{3}\right)} d x-\int_{0}^{1} \frac{x^{3} \ln x}{\left(1+x^{2}\right)\left(1+x^{3}\right)} d x} \\ {=\int_{0}\left(\frac{x+1}{\left(x^{2}+1\right)}-\frac{x^{2}}{\left(x^{3}+1\right)}\right) \ln x d x-\int_{0}\left(\frac{1-x}{\left(x^{2}+1\right)}-\frac{x^{2}-1}{\left(x^{3}+1\right)}\right) \ln x d x} \\ {=\frac{37 \pi^{2}}{432}}\end{array} ∫0∞​(1+x2)(1+x3)lnx​dx=∫0∞​(1+x2)(1+x3)lnx​dx−∫01​(1+x2)(1+x3)x3lnx​dx=∫0​((x2+1)x+1​−(x3+1)x2​)lnxdx−∫0​((x2+1)1−x​−(x3+1)x2−1​)lnxdx=43237π2​​ 第二部分 n(n+1)π≤∫0x∣sin⁡tdtx≤2(n+1)x⇒lim⁡n→∞(∫0x∣sin⁡tdtx)2=4π2\begin{array}{l}{\frac{n}{(n+1) \pi} \leq \frac{\int_{0}^{x} | \sin t d t}{x} \leq \frac{2(n+1)}{x}} \\ {\Rightarrow \lim _{n \rightarrow \infty}\left(\frac{\int_{0}^{x} | \sin t d t}{x}\right)^{2}} \\ {=\frac{4}{\pi^{2}}}\end{array} (n+1)πn​≤x∫0x​∣sintdt​≤x2(n+1)​⇒limn→∞​(x∫0x​∣sintdt​)2=π24​​ 第三部分 exp⁡(3∑k=0x1x+k)=exp⁡(3∫0111+tdt)=8\begin{array}{l}{\exp \left(3 \sum_{k=0}^{x} \frac{1}{x+k}\right)} \\ {=\exp \left(3 \int_{0}^{1} \frac{1}{1+t} d t\right)} \\ {=8}\end{array} exp(3∑k=0x​x+k1​)=exp(3∫01​1+t1​dt)=8​ 第四部分 Lis(1x)∼13125x5+11024x4+124333+132x2+1x⇒x5Li5(1x)−x4−x332∼x2243+x1024+13125\begin{array}{l}{L i_{s}\left(\frac{1}{x}\right)} \\ {\sim \frac{1}{3125 x^{5}}+\frac{1}{1024 x^{4}}+\frac{1}{2433^{3}}+\frac{1}{32 x^{2}}+\frac{1}{x}} \\ {\Rightarrow x^{5} L i_{5}\left(\frac{1}{x}\right)-x^{4}-\frac{x^{3}}{32}} \\ {\sim \frac{x^{2}}{243}+\frac{x}{1024}+\frac{1}{3125}}\end{array} Lis​(x1​)∼3125x51​+1024x41​+243331​+32x21​+x1​⇒x5Li5​(x1​)−x4−32x3​∼243x2​+1024x​+31251​​ 整合方程式 37π254lim⁡(∫0x∣sin⁡t∣dt)2x2243+x21024+13125\frac{37 \pi^{2}}{54} \lim \frac{\left(\int_{0}^{x}|\sin t| d t\right)^{2}}{\frac{x^{2}}{243}+\frac{x^{2}}{1024}+\frac{1}{3125}} 5437π2​lim243x2​+1024x2​+31251​(∫0x​∣sint∣dt)2​ =37π254lim⁡x→+∞(∫02∣sin⁡tdt)2x)21243+11024x+11025x2=\frac{37 \pi^{2}}{54} \lim _{x \rightarrow+\infty} \frac{\left(\frac{\int_{0}^{2} | \sin t d t )^{2}}{x}\right)^{2}}{\frac{1}{243}+\frac{1}{1024 x}+\frac{1}{1025 x^{2}}} =5437π2​x→+∞lim​2431​+1024x1​+1025x21​(x∫02​∣sintdt)2​)2​ =37π254⋅4π2⋅243=666\begin{array}{l}{=\frac{37 \pi^{2}}{54} \cdot \frac{4}{\pi^{2}} \cdot 243} \\ {=666}\end{array} =5437π2​⋅π24​⋅243=666​ 结果 的结果为:]]></content>
      <categories>
        <category>数学</category>
        <category>高级方程式</category>
      </categories>
      <tags>
        <tag>katex</tag>
        <tag>数学公式</tag>
        <tag>fun</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb]]></title>
    <url>%2F2019%2F07%2F14%2FJavaWeb%2F</url>
    <content type="text"><![CDATA[forward和redirect的区别;➕get方式和post方式有何区别;➕什么是cookie?➕session和cookie的区别?;➕Servelet调用流程;➕servletvcontext对象;➕servlet之间进行通信 forward和redirect的区别 实际发生位置不同,地址栏不同 转发是发生在服务器上 转发是由服务器进行跳转的，细心的朋友会发现，在转发的时候，浏览器的地址栏是没有发生变化的，在我访问Servlet111的时候，即使跳转到了Servlet222的页面，浏览器的地址还是Servlet111的。也就是说浏览器是不知道该跳转的动作，转发是对浏览器透明的。通过上面的转发时序图我们也可以发现，实现转发只是一次的http请求，一次转发中request和response对象都是同一个。这也解释了，为什么可以使用request作为域对象进行Servlet之间的通讯。 重定向是发生在浏览器的 重定向是由浏览器进行跳转的，进行重定向跳转的时候，浏览器的地址会发生变化的。曾经介绍过：实现重定向的原理是由response的状态码和Location头组合而实现的。这是由浏览器进行的页面跳转实现重定向会发出两个http请求，request域对象是无效的，因为它不是同一个request对象 用法不同: 很多人都搞不清楚转发和重定向的时候，资源地址究竟怎么写。有的时候要把应用名写上，有的时候不用把应用名写上。很容易把人搞晕。记住一个原则： 给服务器用的直接从资源名开始写，给浏览器用的要把应用名写上 1request.getRequestDispatcher("/资源名 URI").forward(request,response) 转发时&quot;/&quot;代表的是本应用程序的根目录【zhongfucheng 1response.send("/web应用/资源名 URI"); 重定向时&quot;/&quot;代表的是webapps目录 能够去往的URL的范围不一样: 转发是服务器跳转只能去往当前web应用的资源 重定向是服务器跳转，可以去往任何的资源 传递数据的类型不同 转发的request对象可以传递各种类型的数据，包括对象 重定向只能传递字符串 跳转的时间不同 转发时：执行到跳转语句时就会立刻跳转 重定向：整个页面执行完之后才执行跳转 那么转发(forward)和重定向(redirect)使用哪一个？ 根据上面说明了转发和重定向的区别也可以很容易概括出来**。转发是带着转发前的请求的参数的。重定向是新的请求**。 典型的应用场景： 转发: 访问 Servlet 处理业务逻辑，然后 forward 到 jsp 显示处理结果，浏览器里 URL 不变 重定向: 提交表单，处理成功后 redirect 到另一个 jsp，防止表单重复提交，浏览器里 URL 变了 get方式和post方式有何区别 数据携带上 get方式:在URL地址后附带的参数是有限制的,其数据流量通常不超过1kb post方式:可以在请求的实体内容中向服务器发送数据,传送的数据量不限制 请求参数的位置上 get方式:请求参数放在URL地址后边,以?的形式来进行拼接 post方式:请求参数放在HTTP请求包中 用途上 get方式:一般用来获取数据 post方式:一般用来提交数据 原因: 首先是因为get方式携带的数据量比较小,无法携带很大的数据量 post方式提交的参数后台更加容易解析(使用post方式提交的中文数据,后台更加容易解决) get方式比post方式要快 什么是cookie?session和cookie的区别? 什么是cookie 网页之间的交互是通过HTTP的协议传输数据的,而HTTP协议是无状态的协议.一旦数据提交上去后,浏览器与服务器的连接就会关闭,再次交互需要重新建立新的连接 服务器无法确认用户端信息.所以给每个用户都发一个通行证,无论谁访问的时候都需要携带通行证,这样的话服务器就可以确认用户信息 session和cookie的区别: 从存储方式上比较 Cookie只能存储字符串，如果要存储非ASCII字符串还要对其编码。 Session可以存储任何类型的数据，可以把Session看成是一个容器 从隐私安全上比较 Cookie存储在浏览器中，对客户端是可见的。信息容易泄露出去。如果使用Cookie，最好将Cookie加密 Session存储在服务器上，对客户端是透明的。不存在敏感信息泄露问题。 从有效期上比较 Cookie保存在硬盘中，只需要设置maxAge属性为比较大的正整数，即使关闭浏览器，Cookie还是存在的 Session的保存在服务器中，设置maxInactiveInterval属性值来确定Session的有效期。并且Session依赖于名为JSESSIONID的Cookie，该Cookie默认的maxAge属性为-1。如果关闭了浏览器，该Session虽然没有从服务器中消亡，但也就失效了。 从对服务器的负担比较 Session是保存在服务器的，每个用户都会产生一个Session，如果是并发访问的用户非常多，是不能使用Session的，Session会消耗大量的内存。 Cookie是保存在客户端的。不占用服务器的资源。像baidu、Sina这样的大型网站，一般都是使用Cookie来进行会话跟踪。 从浏览器的支持上比较 如果浏览器禁用了Cookie，那么Cookie是无用的了！ 如果浏览器禁用了Cookie，Session可以通过URL地址重写来进行会话跟踪。 从跨域名上比较 Cookie可以设置domain属性来实现跨域名 Session只在当前的域名内有效，不可夸域名 Servelet调用流程 连接web服务器(浏览器) 发送HTTP请求(浏览器) 解析出客户端想访问的主机(web服务器) 解析出客户端想访问的web资源(web服务器) 如果发现servlet是第一次访问,服务器就会第一次加载servlet.并且初始化servlet对象(web服务器) 调用servlet类的init方法(servlet) service方法执行,把数据写入response中(servlet) web服务器把response数据传回浏览器(Web服务器) servletvcontext对象 概念 当tomcat启动的时候,就会创建一个servletcontext对象.他代表着当前web站点 servletcontext怎么用 servletcontext代表着当前web页面,那么所有的servlet对象都共享着同一个servletcontext对象,那么所有的servlet可以通过servletContext进行通信 servletconfig获取的是单个servlet的参数信息,servletcontext可以获取的是配置整个web站点的参数信息 利用servletcontext读取web站点的资源文件 实现servlet的转发(多数使用request的转发) servlet之间进行通信 servletcontext对象可以被称为域对象(可以理解成为容器,类似于map集合) 实现servlet之间的通信就要用到servletcontext的setattribute(string name,object obj)方法,第一个参数是关键字,第二个参数是你要存储的对象 demo1: 1234567//获取到ServletContext对象ServletContext servletContext = this.getServletContext();String value = "mark";//MyName作为关键字，value作为值存进 域对象【类型于Map集合】servletContext.setAttribute("MyName", value); demo2: 1234567//获取ServletContext对象ServletContext servletContext = this.getServletContext();//通过关键字获取存储在域对象的值String value = (String) servletContext.getAttribute("MyName");System.out.println(value);]]></content>
      <categories>
        <category>Java</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>servlet</tag>
        <tag>session</tag>
        <tag>cookie</tag>
        <tag>forward</tag>
        <tag>redirect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合]]></title>
    <url>%2F2019%2F07%2F14%2FJava%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[集合的分类;➕ArrayList和vector的区别;➕HashMap与HashTable的区别;➕HashMap是怎么解决哈希冲突的;➕list和map的区别;➕set里的元素是不能重复的,那么用什么方法区分重复元素;➕ArrayList和linkedlist的存储特性;➕ArrayList集合中插入一万条数据,如何提高效率 集合的分类 主要分为collection,map. collection list ArrayList linkedlist vector(已过时,了解) set hashset linkedhashset treeset map hashmap linkedhashmap hashtable properties concurrenthashmap treemap ArrayList和vector的区别 共同点:这两个类都实现了list接口,他们都是有序的集合(存储有序),底层是数组,允许元素重复和为null 区别: 同步性 ArrayList是非同步的 vector是同步的 需要同步时一般通过collections工具构建同步的ArrayList 扩容大小 vector增长原来的一倍,ArrayList增长原来的0.5倍 HashMap与HashTable的区别？ HashMap没有考虑同步，是线程不安全的；Hashtable使用了synchronized关键字，是线程安全的； HashMap允许K/V都为null；后者K/V都不允许为null； HashMap继承自AbstractMap类；而Hashtable继承自Dictionary类； HashMap的put方法的具体流程？ 源码为: 12345678910111213141516171819202122232425262728293031323334353637383940final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; HashMap.Node&lt;K,V&gt;[] tab; HashMap.Node&lt;K,V&gt; p; int n, i; // 1.如果table为空或者长度为0，即没有元素，那么使用resize()方法扩容 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 2.计算插入存储的数组索引i，此处计算方法同 1.7 中的indexFor()方法 // 如果数组为空，即不存在Hash冲突，则直接插入数组 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); // 3.插入时，如果发生Hash冲突，则依次往下判断 else &#123; HashMap.Node&lt;K,V&gt; e; K k; // a.判断table[i]的元素的key是否与需要插入的key一样，若相同则直接用新的value覆盖掉旧的value // 判断原则equals() - 所以需要当key的对象重写该方法 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // b.继续判断：需要插入的数据结构是红黑树还是链表 // 如果是红黑树，则直接在树中插入 or 更新键值对 else if (p instanceof HashMap.TreeNode) e = ((HashMap.TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 如果是链表，则在链表中插入 or 更新键值对 else &#123; // i .遍历table[i]，判断key是否已存在：采用equals对比当前遍历结点的key与需要插入数据的key // 如果存在相同的，则直接覆盖 // ii.遍历完毕后任务发现上述情况，则直接在链表尾部插入数据 // 插入完成后判断链表长度是否 &gt; 8：若是，则把链表转换成红黑树 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; // 对于i 情况的后续操作：发现key已存在，直接用新value覆盖旧value&amp;返回旧value if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 插入成功后，判断实际存在的键值对数量size &gt; 最大容量 // 如果大于则进行扩容 if (++size &gt; threshold) resize(); // 插入成功时会调用的方法（默认实现为空） afterNodeInsertion(evict); return null;&#125; 图示为: HashMap是怎么解决哈希冲突的 什么是哈希？ Hash，一般翻译为“散列”，也有直接音译为“哈希”的，这就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）；这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。 所有散列函数都有如下一个基本特性：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同。 解决办法 使用链地址法（使用散列表）来链接拥有相同hash值的数据； 使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均； 引入红黑树进一步降低遍历的时间复杂度，使得遍历更快； list和map的区别 存储结构不同 list是存储单列的集合 map是以键值对的形式存储数据的 元素是否重复 list允许元素重复 map不允许元素重复 是否有序 list集合元素是有序的 map集合元素是无序的 set里的元素是不能重复的,那么用什么方法来区分重复的元素,是==还是equals set集合实际上大都使用的是 map集合的put方法来添加元素的 以hashset元素为例,hashset里的元素不能重复 源码为 123456789101112// 1. 如果key 相等 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p;// 2. 修改对应的value if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; 添加元素的时候,如果key(也就是对应的是set集合的元素)相等,那么修改value值.而在set集合中,value值仅仅是一个object对象罢了(该对象对set集合来说是无用的) Set集合如果添加的元素相同时，是根本没有插入的(仅修改了一个无用的value值)！从源码(HashMap)中也看出来，==和equals()方法都有使用！ arraylist和linkedlist的存储特性 ArrayList的底层是数组，LinkedList的底层是双向链表。 ArrayList它支持以角标位置进行索引出对应的元素(随机访问)，而LinkedList则需要遍历整个链表来获取对应的元素。因此一般来说ArrayList的访问速度是要比LinkedList要快的 ArrayList由于是数组，对于删除和修改而言消耗是比较大(复制和移动数组实现)，LinkedList是双向链表删除和修改只需要修改对应的指针即可，消耗是很小的。因此一般来说LinkedList的增删速度是要比ArrayList要快的 ArrayList的增删未必就是比LinkedList要慢。 如果增删都是在末尾来操作【每次调用的都是remove()和add()】，此时ArrayList就不需要移动和复制数组来进行操作了。如果数据量有百万级的时，速度是会比LinkedList要快的。 如果删除操作的位置是在中间。由于LinkedList的消耗主要是在遍历上，ArrayList的消耗主要是在移动和复制上(底层调用的是arraycopy()方法，是native方法)。 LinkedList的遍历速度是要慢于ArrayList的复制移动速度的 如果数据量有百万级的时，还是ArrayList要快。 ArrayList集合中插入一万条数据,如何提高效率 ArrayList的默认初始容量为10，要插入大量数据的时候需要不断扩容，而扩容是非常影响性能的。因此，现在明确了10万条数据了，我们可以直接在初始化的时候就设置ArrayList的容量.]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java辨析题]]></title>
    <url>%2F2019%2F07%2F14%2FJava%E8%BE%A8%E6%9E%90%E9%A2%98%2F</url>
    <content type="text"><![CDATA[==和equals;➕continue和break;final, finally, finalize的区别;➕String和StringBuffer的对比;➕JDK,JRE和JVM的区别和联系;➕接口和抽象类的区别以及联系 ==和equals ==: 比较的是两个字符串内存地址(堆内存)的数值是否相等,属于数值比较. equals(): 比较的是两个字符串的内容,属于内容比较,所以以后字符串相等判断的时候都使用equals. equals这个方法的初始默认行为行为是比较字符串的内存地址值,一般来说意义不大,所以,在一些类库中这个方法被重写了,如string,integer,date.在这些类中equals有其自身的实现(一般来说是比较对象的成员变量值是否相等),而不去比较字符串的内存地址. continue和break continue 跳出本次循环继续下一个循环. break 跳出循环体,继续执行循环体味道函数体 return 跳出循环体,函数体后边的部分不再执行 final, finally, finalize的区别 final用于声明属性,方法和类.分别表示属性不可变,方法不可重写(可重载),类不可继承 finally是异常处理语句结构的一部分 finalize是object类的一个方法,在垃圾收集器执行的时候会被调用被回收对象的此方法可以覆盖此方法提供垃圾收集时的其他资源回收,例如关闭软件 String和StringBuffer的对比 stringbuffer :保存的是字符串常量,里边的值可以被修改,比较适合做字符串的更新操作,效率较高. string :保存的是字符串常量,里边的值不能改变,每次只能更改内存地址,所以不适合做字符串的更新操作,适合作为数据库存储. JDK,JRE和JVM的区别和联系 JDK(Java Development Kit):Java开发工具包 JRE(Java runtime environment):Java运行环境 JVM(Java Virtual Machine):Java虚拟机 三者联系: JVM不能单独搞定class的执行，解释class的时候JVM需要调用解释所需要的类库lib。在JDK下面的的jre目录里面有两个文件夹bin和lib,在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。JVM+Lib=JRE。总体来说就是，我们利用JDK（调用JAVA API）开发了属于我们自己的JAVA程序后，通过JDK中的编译程序（javac）将我们的文本java文件编译成JAVA字节码，在JRE上运行这些JAVA字节码，JVM解析这些字节码，映射到CPU指令集或OS的系统调用。 三者区别: JDK和JRE区别：在bin文件夹下会发现，JDK有javac.exe而JRE里面没有，javac指令是用来将java文件编译成class文件的，这是开发者需要的，而用户（只需要运行的人）是不需要的。JDK还有jar.exe, javadoc.exe等等用于开发的可执行指令文件。这也证实了一个是开发环境，一个是运行环境。 JRE和JVM区别：JVM并不代表就可以执行class了，JVM执行.class还需要JRE下的lib类库的支持，尤其是rt.jar。 接口和抽象类的区别以及联系 联系: 都是上层的抽象层 都不能被实例化 都包含抽象的方法,用于描述类具备的功能,但是不提供具体的实现 区别: 在抽象类中可以写非抽象的方法,从而避免在子类中重复书写他们,这样可以提高代码的复用性,这是抽象类的优势.接口中只有抽象类的方法 一个类只能继承一个直接父类,这个父类可以是具体的类也可以是抽象类.但是一个类可以实现多个接口. Java语言中类的继承是单继承原因是：当子类重写父类方法的时候，或者隐藏父类的成员变量以及静态方法的时候，JVM使用不同的绑定规则。如果一个类有多个直接的父类，那么会使绑定规则变得更复杂。为了简化软件的体系结构和绑定机制，java语言禁止多继承。接口可以多继承，是因为接口中只有抽象方法，没有静态方法和非常量的属性，只有接口的实现类才会重写接口中方法。因此一个类有多个接口也不会增加JVM的绑定机制和复杂度。对于已经存在的继承树，可以方便的从类中抽象出新的接口，但是从类中抽象出新的抽象类就不那么容易了，因此接口更有利于软件系统的维护和重构。 未完待续😉]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>易混淆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VIM操作]]></title>
    <url>%2F2019%2F07%2F14%2FVIM%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Vim是从vi发展出来的一个文本编辑器。其代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。和Emacs并列成为类Unix系统用户最喜欢的编辑器。 写入\保存\退出 1234567891011121314:q[uit] " 退出:q! " 强制退出:w[rite] " 保存:w! " 强制保存，能不能保存成功取决于用户对文件的权限:w ! sudo tee % " 如果没有权限保存，试试这个命令ZZ " 两个大写的 Z，没有修改直接退出，有修改保存后退出:w newfilename " 另存为新文件:1, 10 w newfilename " 将 1 到 10 行的内容另存为新文件:1, 10 w &gt;&gt; filename " 将 1 到 10 行的内容另存为新文件:r filename " 将目标文件的内容追加到当前光标下一行:3 r filename " 将目标文件的内容追加到第 3 行一下:! ls " 暂时离开 Vim 查看当前目录的文件，回车后返回 Vim 光标移动 1234567891011121314151617181920212223242526272829h " 方向键 ←j " 方向键 ↓k " 方向键 ↑l " 方向键 →0 " 移动到行首$ " 移动到行尾的回车符g_ " 移动到行尾最后一个非空字符gg " 移动到第一行G " 移动到最后一行"w " 移动到下一个单词开头e " 移动到单词的结尾b " 移动到单词的开头" 不常用nh " 向左移动 n 格，n 为数字nl " 向右移动 n 格nj " 向下移动 n 行nk " 向上移动 n 行n&lt;space&gt; " 向右移动 n 格，同 nlH " 移动到当前屏幕第一行的第一个字符M " 移动到当前屏幕中间行的第一个字符L " 移动到当前屏幕最后一行的第一个字符+ " 移动到非空白字符的下一行- " 移动到非空白字符的上一行:n&lt;cr&gt; " 跳转到第 n 行 翻页 1234&lt;c-f&gt; " 向下移动一页&lt;c-d&gt; " 向下移动半页&lt;c-b&gt; " 向上移动一页&lt;c-u&gt; " 向上移动半页 查找和替换 12345678/word " 从光标位置向下搜索 word 单词?word " 从光标位置向上搜索 word 单词n " 英文字母 n，根据 / 或 ? 搜索的方向定位到下一个匹配目标N " 与 n 相反，定位匹配目标:n1,n2s/word1/word2/g " n1, n2 表示数字，替换 n1 行到 n2 行的单词:1,$s/word1/word2/g " 全文替换，也可以写成 :%s/word1/word2/g:1,$s/word1/word2/gc " 全文替换，并出现确认提示 复制\粘贴\删除 12345678910111213141516171819202122232425262728x " 向后删除一个字符nx " 向后删除 n 个字符X " 向前删除一个字符nX " 向前删除 n 个字符dd " 删除当前行ndd " 向下删除 n 行d1G / dgg " 删除第一行到当前行的数据dG " 删除当前行到最后一行的数据d$ " 删除当前字符到行尾D " 删除当前字符到行尾d0 " 从行首删除到当前字符yy " 复制当前行Y " 复制当前行nyy " 从当前行开始复制 n 行y1G / ygg " 从第一行复制到当前行yG " 从当前行复制到最后一行y0 " 从行首复制到当前字符y$ " 从当前字符复制到行尾p, P " 黏贴，p 黏贴到光标下一行，P 黏贴到光标上一行yyp " 复制并粘贴ddp " 删除并粘贴，相当于下移当前行"+y " 复制本文到系统剪切板"+p " 粘贴系统剪切板到 Vim（不会影响文本格式） 插入 123456789101112131415161718i " 在光标前进入 insert 模式I " 在当前行左边第一个非空字符前进入 insert 模式，类似其他编辑器的 &lt;c-a&gt; 快捷键a " 在光标后进入 insert 模式A " 在当前行右边第一个非空字符前进入 insert 模式，类似其他编辑器的 &lt;c-e&gt; 快捷键o " 在光标的下一行插入O " 在光标的上一行插入s " 删除当前字符，并进入 insert 模式S " 删除当前行，并进入插入模式vc " 删除当前字符，并进入 insert 模式cc " 删除当前行，并进入插入模式c0 " 删除光标位置到行首，并进入 insert 模式cg_ " 删除光标位置到行尾最后一个非空字符，并进入 insert 模式ce " 删除光标位置到单词末尾，并进入 insert 模式cw " 删除光标位置到单词末尾，并进入 insert 模式ciw " 删除当前单词，并进入 insert 模式cip " 删除整个段落，并进入 insert 模式ci( " 删除当前括号内的内容，并进入 insert 模式 适用于 ([&#123;&lt;'` 等所有成对的标签 撤销重做 123u " 撤销&lt;c-r&gt; " 重做. " 重复完成操作 替换 12r " 替换单个字符，自动返回 normal 模式R " 连续替换多个字符，手动 &lt;esc&gt; 返回 normal 模式 大小写 1234567891011121314~ " 当前字符大小写反转g~~ " 正行字符大小写反转vu " 当前字符小写vU " 当前字符大写vU " 当前字符大写viwu " 当前字符小写viwU " 当前字符大写ggguG " 文本所有字符小写gggUG " 文本所有字符大写:%s/\&lt;./\u&amp;/g " 将所有单词首字母大写（需要使用 :nohls 去掉高亮）:%s/\&lt;./\l&amp;/g " 将所有单词首字母小写:%s/.*/\u&amp; " 将每行第一个字母大写:%s/.*/\l&amp; " 将每行第一个字母小写 多窗口操作 1234567891011:sp filename " 上下分割窗口:vsp filename " 左右分割窗口&lt;c-w&gt;h[j[k[l]]] " 根据方向键移动光标到该方向的窗口上&lt;c-w&gt;r " 顺时针转动窗口&lt;c-w&gt;R " 逆时针转动窗口&lt;c-w&gt;x " 对调左右或上下两个对应的窗口&lt;c-w&gt;q " 退出窗口:q " 退出窗口 多文件编辑 12345678vim file1 file2 " 同时打开两个文件:files " 查看现在编辑的文件列表，%a 代表正在操作哪个文件 1 %a "file1" line 1 2 "file2" line 0:n " 跳到下一个文件，这里的 n 就是字母:N " 跳到上一个文件]]></content>
      <categories>
        <category>linux</category>
        <category>vim操作</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F07%2F14%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式（英语：Regular Expression，在代码中常简写为regex、regexp或RE），又称正则表示式、正则表示法、规则表达式、常规表示法，是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。 正则表达式 字符 描述 \ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。串行“\\”匹配“\”而“\(”则匹配“(”。 ^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo*能匹配“z”以及“zoo”。*等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 ? 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。 {n} n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。 {n,} n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。 {n,m} m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。 . 匹配除“\n”之外的任何单个字符。要匹配包括“\n”在内的任何字符，请使用像“(.|\n)”的模式。 (pattern) 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\(”或“\)”。 (?:pattern) 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。 (?=pattern) 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 (?&lt;=pattern) 反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。 (?&lt;!pattern) 反向否定预查，与正向否定预查类拟，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。 x|y 匹配x或y。例如，“z|food”能匹配“z”或“food”。“(z|f)ood”则匹配“zood”或“food”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“p”。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。 \b 匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。 \B 匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。 \cx 匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。 \d 匹配一个数字字符。等价于[0-9]。 \D 匹配一个非数字字符。等价于[^0-9]。 \f 匹配一个换页符。等价于\x0c和\cL。 \n 匹配一个换行符。等价于\x0a和\cJ。 \r 匹配一个回车符。等价于\x0d和\cM。 \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。 \S 匹配任何非空白字符。等价于[^ \f\n\r\t\v]。 \t 匹配一个制表符。等价于\x09和\cI。 \v 匹配一个垂直制表符。等价于\x0b和\cK。 \w 匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。 \W 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。 \xn 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\x41”匹配“A”。“\x041”则等价于“\x04&amp;1”。正则表达式中可以使用ASCII编码。. \num 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\1”匹配两个连续的相同字符。 \n 标识一个八进制转义值或一个向后引用。如果*n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n*为一个八进制转义值。 \nm 标识一个八进制转义值或一个向后引用。如果nm之前至少有nm个获得子表达式，则nm为向后引用。如果*nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则*nm将匹配八进制转义值nm。 \nml 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 \un 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（©）。 常见的正则表达式 用户名 /[1]{3,16}$/ 密码 /[2]{6,18}$/ 十六进制值 /^#?([a-f0-9]{6}|[a-f0-9]{3})$/ 电子邮箱 /^([a-z0-9_.-]+)@([\da-z.-]+).([a-z.]{2,6})/ /^[a-z\d]+(\.[a-z\d]+)*@([\da-z](-[\da-z])?)+(\.{1,2}[a-z]+)+/ URL /^(https?😕/)?([\da-z.-]+).([a-z.]{2,6})([/\w .-])/?$/ IP 地址 /((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)/ /^(?😦?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/ HTML 标签 /&lt;([a-z]+)([&lt;]+)(?:&gt;(.)&lt;/\1&gt;|\s+/&gt;)$/ 删除代码\注释 (?&lt;!http:|\S)//.*$ Unicode编码中的汉字范围 /[3]+$/ a-z0-9_- ↩︎ a-z0-9_- ↩︎ \u2E80-\u9FFF ↩︎]]></content>
      <categories>
        <category>linux</category>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>正则表达式</tag>
        <tag>查询</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令]]></title>
    <url>%2F2019%2F07%2F13%2Flinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Linux是一种自由和开放源码的类UNIX 操作系统。该操作系统的内核由林纳斯·托瓦兹在1991年10月5日首次发布[5][6]，在加上用户空间的应用程序之后，成为 Linux 操作系统。Linux 也是自由软件和开放源代码软件发展中最著名的例子。只要遵循 GNU 通用公共许可证（GPL），任何个人和机构都可以自由地使用 Linux 的所有底层源代码，也可以自由地修改和再发布。大多数 Linux 系统还包括像提供 GUI 的 X Window 之类的程序。除了一部分专家之外，大多数人都是直接使用 Linux 发行版，而不是自己选择每一样组件或自行设置 cd命令 这是一个非常基本，也是大家经常需要使用的命令，它用于切换当前目录，它的参数是要切换到的目录的路径，可以是绝对路径，也可以是相对路径。如： 123cd /root/Docements # 切换到目录/root/Docementscd ./path # 切换到当前目录下的path目录中，“.”表示当前目录 cd ../path # 切换到上层目录中的path目录中，“..”表示上一层目录 ls命令 这是一个非常有用的查看文件与目录的命令，list之意，它的参数非常多，如下： -l ：列出长数据串，包含文件的属性与权限数据等 -a ：列出全部的文件，连同隐藏文件（开头为.的文件）一起列出来（常用） -d ：仅列出目录本身，而不是列出目录的文件数据 -h ：将文件容量以较易读的方式（GB，kB等）列出来 -R ：连同子目录的内容一起列出（递归列出），等于该目录下的所有文件都会显示出来 注：这些参数也可以组合使用 下面举两个例子 12ls -l #以长数据串的形式列出当前目录下的数据文件和目录ls -lR #以长数据串的形式列出当前目录下的所有文件 grep命令 该命令常用于分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工等等，它的简单语法为: grep [-acinv] [--color=auto] '查找字符串' filename 它的常用参数如下： -a ：将binary文件以text文件的方式查找数据 -c ：计算找到‘查找字符串’的次数 -i ：忽略大小写的区别，即把大小写视为相同 -v ：反向选择，即显示出没有‘查找字符串’内容的那一行 例如： 取出文件/etc/man.config中包含MANPATH的行，并把找到的关键字加上颜色 grep --color=auto 'MANPATH' /etc/man.config 把ls -l的输出中包含字母file（不区分大小写）的内容输出 ls -l | grep -i file find命令 find是一个基于查找的功能非常强大的命令，相对而言，它的使用也相对较为复杂，参数也比较多，所以在这里将给把它们分类列出，它的基本语法如下： find [PATH] [option] [action] 与时间有关的参数 -mtime n : n为数字，意思为在n天之前的“一天内”被更改过的文件 -mtime +n : 列出在n天之前（不含n天本身）被更改过的文件名 -mtime -n : 列出在n天之内（含n天本身）被更改过的文件名 -newer file : 列出比file还要新的文件名 例如： 1find /root -mtime 0 # 在当前目录下查找今天之内有改动的文件 与用户或用户组名有关的参数 -user name : 列出文件所有者为name的文件 -group name : 列出文件所属用户组为name的文件 -uid n : 列出文件所有者为用户ID为n的文件 -gid n : 列出文件所属用户组为用户组ID为n的文件 例如： 1find /home/ljianhui -user ljianhui # 在目录/home/ljianhui中找出所有者为ljianhui的文件 与文件权限及名称有关的参数 -name filename ：找出文件名为filename的文件 -size [±]SIZE ：找出比SIZE还要大（+）或小（-）的文件 -tpye TYPE ：查找文件的类型为TYPE的文件，TYPE的值主要有：一般文件（f)、设备文件 （b、c）、目录（d）、连接文件（l）、socket（s）、FIFO管道文件（p） -perm mode ：查找文件权限刚好等于mode的文件，mode用数字表示，如0755 -perm -mode ：查找文件权限必须要全部包括mode权限的文件，mode用数字表示 -perm +mode ：查找文件权限包含任一mode的权限的文件，mode用数字表示 例如： 123find / -name passwd # 查找文件名为passwd的文件find . -perm 0755 # 查找当前目录中文件权限的0755的文件find . -size +12k # 查找当前目录中大于12KB的文件，注意c表示byte cp命令 该命令用于复制文件，copy之意，它还可以把多个文件一次性地复制到一个目录下，它的常用参数如下： -a ：将文件的特性一起复制 -p ：连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份 -i ：若目标文件已经存在时，在覆盖时会先询问操作的进行 -r ：递归持续复制，用于目录的复制行为 -u ：目标文件与源文件有差异时才会复制 例如 ： 12cp -a file1 file2 #连同文件的所有特性把文件file1复制成文件file2cp file1 file2 file3 dir #把文件file1、file2、file3复制到目录dir中 mv命令 该命令用于移动文件、目录或更名，move之意，它的常用参数如下： -f ：force强制的意思，如果目标文件已经存在，不会询问而直接覆盖 -i ：若目标文件已经存在，就会询问是否覆盖 -u ：若目标文件已经存在，且比目标文件新，才会更新 注：该命令可以把一个文件或多个文件一次移动一个文件夹中，但是最后一个目标文件一定要是“目录”。 例如： 12mv file1 file2 file3 dir # 把文件file1、file2、file3移动到目录dir中mv file1 file2 # 把文件file1重命名为file2 rm命令 该命令用于删除文件或目录，remove之间，它的常用参数如下： -f ：就是force的意思，忽略不存在的文件，不会出现警告消息 -i ：互动模式，在删除前会询问用户是否操作 -r ：递归删除，最常用于目录删除，它是一个非常危险的参数 例如： 12rm -i file # 删除文件file，在删除之前会询问是否进行该操作rm -fr dir # 强制删除目录dir中的所有文件 ps命令 该命令用于将某个时间点的进程运行情况选取下来并输出，process之意，它的常用参数如下： -A ：所有的进程均显示出来 -a ：不与terminal有关的所有进程 -u ：有效用户的相关进程 -x ：一般与a参数一起使用，可列出较完整的信息 -l ：较长，较详细地将PID的信息列出 其实我们只要记住ps一般使用的命令参数搭配即可，它们并不多，如下： 1234ps aux # 查看系统所有的进程数据ps ax # 查看不与terminal有关的所有进程ps -lA # 查看系统所有的进程数据ps axjf # 查看连同一部分进程树状态 kill命令 该命令用于向某个工作（%jobnumber）或者是某个PID（数字）传送一个信号，它通常与ps和jobs命令一起使用，它的基本语法如下： kill -signal PID signal的常用参数如下： 注：最前面的数字为信号的代号，使用时可以用代号代替相应的信号。 1：SIGHUP，启动被终止的进程 2：SIGINT，相当于输入ctrl+c，中断一个程序的进行 9：SIGKILL，强制中断一个进程的进行 15：SIGTERM，以正常的结束进程方式来终止进程 17：SIGSTOP，相当于输入ctrl+z，暂停一个进程的进行 例如： 以正常的结束进程方式来终于第一个后台工作，可用jobs命令查看后台中的第一个工作进程 kill -SIGTERM %1 重新改动进程ID为PID的进程，PID可用ps命令通过管道命令加上grep命令进行筛选获得 kill -SIGHUP PID killall命令 该命令用于向一个命令启动的进程发送一个信号，它的一般语法如下： killall [-iIe] [command name] 它的参数如下： -i ：交互式的意思，若需要删除时，会询问用户 -e ：表示后面接的command name要一致，但command name不能超过15个字符 -I ：命令名称忽略大小写 例如： 1killall -SIGHUP syslogd # 重新启动syslogd file命令 该命令用于判断接在file命令后的文件的基本数据，因为在Linux下文件的类型并不是以后缀为分的，所以这个命令对我们来说就很有用了，它的用法非常简单，基本语法如下： file filename 例如： file ./test tar命令 该命令用于对文件进行打包，默认情况并不会压缩，如果指定了相应的参数，它还会调用相应的压缩程序（如gzip和bzip等）进行压缩和解压。它的常用参数如下： -c ：新建打包文件 -t ：查看打包文件的内容含有哪些文件名 -x ：解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同一条命令中 -j ：通过bzip2的支持进行压缩/解压缩 -z ：通过gzip的支持进行压缩/解压缩 -v ：在压缩/解压缩过程中，将正在处理的文件名显示出来 -f filename ：filename为要处理的文件 -C dir ：指定压缩/解压缩的目录dir 通常我们只需要记住下面三条命令即可： 压缩：tar -jcv -f filename.tar.bz2 要被处理的文件或目录名称 查询：tar -jtv -f filename.tar.bz2 解压：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录 注：文件名并不定要以后缀tar.bz2结尾，这里主要是为了说明使用的压缩程序为bzip2 cat命令 该命令用于查看文本文件的内容，后接要查看的文件名，通常可用管道与more和less一起使用，从而可以一页页地查看数据。例如： 1cat text | less # 查看text文件中的内容 注：这条命令也可以使用less text来代替 chgrp命令 该命令用于改变文件所属用户组，它的使用非常简单，它的基本用法如下： chgrp [-R] dirname/filename -R ：进行递归的持续对所有文件和子目录更改 例如： 1chgrp users -R ./dir # 递归地把dir目录下中的所有文件和子目录下所有文件的用户组修改为users chown命令 该命令用于改变文件的所有者，与chgrp命令的使用方法相同，只是修改的文件属性不同 chmod命令 该命令用于改变文件的权限，一般的用法如下： chmod [-R] xyz 文件或目录 -R：进行递归的持续更改，即连同子目录下的所有文件都会更改 同时，chmod还可以使用u（user）、g（group）、o（other）、a（all）和+（加入）、-（删除）、=（设置）跟rwx搭配来对文件的权限进行更改。 例如： 12chmod 0755 file # 把file的文件权限改变为-rxwr-xr-xchmod g+w file # 向file的文件权限中加入用户组可写权限 time命令 该命令用于测算一个命令（即程序）的执行时间。它的使用非常简单，就像平时输入命令一样，不过在命令的前面加入一个time即可，例如： time ./process time ps aux 在程序或命令运行结束后，在最后输出了三个时间，它们分别是： user：用户CPU时间，命令执行完成花费的用户CPU时间，即命令在用户态中执行时间总和 system：系统CPU时间，命令执行完成花费的系统CPU时间，即命令在核心态中执行时间总和 real：实际时间，从command命令行开始执行到运行终止的消逝时间 注：用户CPU时间和系统CPU时间之和为CPU时间，即命令占用CPU执行的时间总和。实际时间要大于CPU时间，因为Linux是多任务操作系统，往往在执行一条命令时，系统还要处理其它任务。另一个需要注意的问题是即使每次执行相同命令，但所花费的时间也是不一样，其花费时间是与系统运行相关的。]]></content>
      <categories>
        <category>linux</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux系统目录详情]]></title>
    <url>%2F2019%2F07%2F13%2Flinux%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E8%AF%A6%E6%83%85%2F</url>
    <content type="text"><![CDATA[随着对Linux使用的经验的加深，我们会了解越来越多的目录。对目录的功能知道得越多，我们对Linux系统的工作原理就理解的越深刻，理解操作系统的工作原理，更助于我们更为规范地使用和理解系统中每个目录存在的意义，直至最后几乎知道系统中的每个文件…… 系统启动 /boot：存放的启动Linux 时使用的内核文件，包括连接文件以及镜像文件。 /etc：存放所有的系统需要的配置文件和子目录列表，更改目录下的文件可能会导致系统不能启动。 /lib：存放基本代码库（比如c++库），其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。 /sys： 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中 指令集合 /bin：存放着最常用的程序和指令 /sbin：只有系统管理员能使用的程序和指令。 外部文件管理 /dev：Device(设备)的缩写, 存放的是Linux的外部设备。注意：在Linux中访问设备和访问文件的方式是相同的。 /media：类windows的其他设备，例如U盘、光驱等等，识别后linux会把设备放到这个目录下。 /mnt：临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。 临时文件 /run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。 /lost+found：一般情况下为空的，系统非法关机后，这里就存放一些文件。 /tmp：这个目录是用来存放一些临时文件的。 账户 /root：系统管理员的用户主目录。 /home：用户的主目录，以用户的账号命名的。 /usr：用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。 /usr/bin：系统用户使用的应用程序与指令。 /usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src：内核源代码默认的放置目录。 运行过程中要用 /var：存放经常修改的数据，比如程序运行的日志文件（/var/log 目录下）。 /proc：管理内存空间！虚拟的目录，是系统内存的映射，我们可以直接访问这个目录来，获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件来做修改。 拓展需要 /opt：默认是空的，我们安装额外软件可以放在这个里面。 /srv：存放服务启动后需要提取的数据（不用服务器就是空）]]></content>
      <categories>
        <category>linux</category>
        <category>目录</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>目录解释</tag>
      </tags>
  </entry>
</search>
