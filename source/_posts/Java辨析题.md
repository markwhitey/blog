---
title: Java辨析题
date: 2019-07-14 11:28:39
description: 
tags: 
- Java
- Interview
categories:
- Java
- Basis
top:
---

{% cq %}==和equals;➕continue和break;final, finally, finalize的区别;➕String和StringBuffer的对比;➕JDK,JRE和JVM的区别和联系;➕接口和抽象类的区别以及联系{% endcq %}  

<!-- more --> 

# ==和equals  

------

- **==:** 比较的是两个字符串内存地址(堆内存)的数值是否相等,属于数值比较.  
- **equals():** 比较的是两个字符串的内容,属于内容比较,**所以以后字符串相等判断的时候都使用equals**.  

> equals这个方法的初始默认行为行为是比较字符串的内存地址值,一般来说意义不大,所以,在一些类库中这个方法被重写了,如string,integer,date.在这些类中equals有其自身的实现(一般来说是比较对象的成员变量值是否相等),而不去比较字符串的内存地址.  

</br>

# continue和break

------

- **continue** 跳出本次循环继续下一个循环.
- **break** 跳出循环体,继续执行循环体味道函数体
- **return** 跳出循环体,函数体后边的部分不再执行

</br>

# final, finally, finalize的区别

------

- final用于声明属性,方法和类.分别表示属性不可变,方法不可重写(可重载),类不可继承
- finally是异常处理语句结构的一部分
- finalize是object类的一个方法,在垃圾收集器执行的时候会被调用被回收对象的此方法可以覆盖此方法提供垃圾收集时的其他资源回收,例如关闭软件

</br>

# String和StringBuffer的对比

------

- **stringbuffer** :保存的是字符串常量,里边的值可以被修改,比较适合做字符串的更新操作,效率较高.
- **string** :保存的是字符串常量,里边的值不能改变,每次只能更改内存地址,所以不适合做字符串的更新操作,适合作为数据库存储.

</br>

# JDK,JRE和JVM的区别和联系

------

JDK(Java Development Kit):Java开发工具包
JRE(Java runtime environment):Java运行环境
JVM(Java Virtual Machine):Java虚拟机

- __三者联系:__
  - JVM不能单独搞定class的执行，解释class的时候JVM需要调用解释所需要的类库lib。在JDK下面的的jre目录里面有两个文件夹bin和lib,在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。JVM+Lib=JRE。总体来说就是，我们利用JDK（调用JAVA API）开发了属于我们自己的JAVA程序后，通过JDK中的编译程序（javac）将我们的文本java文件编译成JAVA字节码，在JRE上运行这些JAVA字节码，JVM解析这些字节码，映射到CPU指令集或OS的系统调用。
- __三者区别:__
  - JDK和JRE区别：在bin文件夹下会发现，JDK有javac.exe而JRE里面没有，javac指令是用来将java文件编译成class文件的，这是开发者需要的，而用户（只需要运行的人）是不需要的。JDK还有jar.exe, javadoc.exe等等用于开发的可执行指令文件。这也证实了一个是开发环境，一个是运行环境。
  - JRE和JVM区别：JVM并不代表就可以执行class了，JVM执行.class还需要JRE下的lib类库的支持，尤其是rt.jar。

<br>

# 接口和抽象类的区别以及联系

------

- 联系:
  - 都是上层的抽象层
  - 都不能被实例化
  - 都包含抽象的方法,用于描述类具备的功能,但是不提供具体的实现
- 区别:
  - 在抽象类中可以写非抽象的方法,从而避免在子类中重复书写他们,这样可以提高代码的复用性,这是抽象类的优势.接口中只有抽象类的方法
  - 一个类只能继承一个直接父类,这个父类可以是具体的类也可以是抽象类.但是一个类可以实现多个接口.

> Java语言中类的继承是单继承原因是：当子类重写父类方法的时候，或者隐藏父类的成员变量以及静态方法的时候，JVM使用不同的绑定规则。如果一个类有多个直接的父类，那么会使绑定规则变得更复杂。为了简化软件的体系结构和绑定机制，java语言禁止多继承。接口可以多继承，是因为接口中只有抽象方法，没有静态方法和非常量的属性，只有接口的实现类才会重写接口中方法。因此一个类有多个接口也不会增加JVM的绑定机制和复杂度。对于已经存在的继承树，可以方便的从类中抽象出新的接口，但是从类中抽象出新的抽象类就不那么容易了，因此接口更有利于软件系统的维护和重构。

<br>

# 未完待续😉



