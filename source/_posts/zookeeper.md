---
title: Hadoop框架--Zookeeper笔记
mathjax: false
date: 2019-08-31 10:26:02
tags:
- Big Data
categories:
- Big Data
- Hadoop
top:
photo:
---



{% cq %}

Zookeeper 常被用于分布式协调服务（即服务或元数据注册等场景，如 Dubbo、Kafka：将生产者或元数据信息注册到 Zookeeper 集群上，以便分布式系统其他参与者及时看到，因为 Zookeeper 实现了类似 Paxos 的 Zab 协议，解决了分布式数据一致性问题）、分布式锁等用途

{% endcq %}

<!-- more -->

<br>

# CAP理论

---

> **一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项**。

## **Consistency 一致性**

一致性指 {% label danger @all nodes see the same data at the same time %}，即所有节点在同一时间的数据完全一致。

一致性是因为多个数据拷贝下并发读写才有的问题，因此理解时一定要注意结合考虑多个数据拷贝下并发读写的场景。

**对于一致性，可以分为从客户端和服务端两个不同的视角。**

- **客户端**

  从客户端来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题

- **服务端**

  从服务端来看，则是更新如何分布到整个系统，以保证数据最终一致。

**对于一致性，可以分为强 / 弱 / 最终一致性三类**

从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。

- **强一致性**

  对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值。这种是对用户最友好的，就是用户上一次写什么，下一次就保证能读到什么。当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值。这种是对用户最友好的，就是用户上一次写什么，下一次就保证能读到什么。

- **弱一致性**

  系统并不保证进程或者线程的访问都会返回最新的更新过的值。系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到。但会尽可能保证在某个时间级别（比如秒级别）之后，可以让数据达到一致性状态。

- **最终一致性**

  如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。

## **Availability 可用性**

可用性指 {% label danger @Reads and writes always succeed %}，即服务在正常响应时间内一直可用。

好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。可用性通常情况下可用性和分布式数据冗余，负载均衡等有着很大的关联。

## **Partition Tolerance 分区容错性**

分区容错性指 {% label danger @the system continues to operate despite arbitrary message loss or failure of part of the system %}，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性或可用性的服务。

## **CAP 权衡**

**无法满足CAP理论的情况:**

- **CA without P**：如果不要求 P（不允许分区），则 C（强一致性）和 A（可用性）是可以保证的。但其实分区不是你想不想的问题，而是始终会存在，因此 CA 的系统更多的是允许分区后各子系统依然保持 CA。
- **CP without A**：如果不要求 A（可用），相当于每个请求都需要在 Server 之间强一致，而 P（分区）会导致同步时间无限延长，如此 CP 也是可以保证的。很多传统的数据库分布式事务都属于这种模式。
- **AP wihtout C**：要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。现在众多的 NoSQL 都属于此类。

### AP

对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到 N 个 9，即保证 P 和 A，舍弃 C（退而求其次保证最终一致性）。虽然某些地方会影响客户体验，但没达到造成用户流程的严重程度。

### CA

对于涉及到钱财这样不能有一丝让步的场景，C 必须保证**。网络发生故障宁可停止服务，这是保证 CA，舍弃 P。貌似这几年国内银行业发生了不下 10 起事故，但影响面不大，报道也不多，广大群众知道的少。还有一种是保证 CP，舍弃 A。例如网络故障事只读不写。

### CP

**分布式数据库、缓存 redis、注册中心 zookeeper**，只要是分布式存储数据的软件，都必须首先满足数据强一致性。其次分布式，肯定满足集群。可用性可以暂时失去。

<br>

# ZooKeeper如何实现一致性的

---

## ZooKeeper的顺序一致性

> *the result of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program.*

ZooKeeper通过实现分布式锁来实现最终的一致性

实际上，Zookeeper的一致性更复杂一些，Zookeeper的读操作是sequential consistency的，Zookeeper的写操作是linearizability的。

为什么Zookeeper要实现sequential consistency？Zookeeper最核心的功能是用来做coordination service，也就是用来做分布式锁服务，在分布式的环境下，Zookeeper本身怎么做到“天然正确”？没有其他的synchronization机制保证Zookeeper是正确的，所以只要Zookeeper实现了sequential consistency，那它自身就可以保证正确性，从而对外提供锁服务。

## ZooKeeper如何实现一致性

1. zookeeper 本身是集群，作用和目的就是为了高可用——即 leader 挂了，自动选举新的 leader。

2. **但是 leader 节点只有一个，并且对外提供服务的也只有这一个 Leader 节点，所以很明显不是高可用，因为 leader 挂了之后，选举有时间差几十秒，这段时间差之内就是不可用！**

3. 所以，zookeeper 不是高可用，而是数据一致性和集群，即 CP。

ZooKeeper 是个 CP（**一致性 + 分区容错性**）的，即任何时刻对 ZooKeeper 的访问请求能得到一致的数据结果，同时系统对网络分割具备容错性。但是它不能保证每次服务请求的可用性，也就是在极端环境下，ZooKeeper 可能会丢弃一些请求，消费者程序需要重新请求才能获得结果。ZooKeeper 是分布式协调服务，它的职责是保证数据在其管辖下的所有服务之间保持同步、一致。

<br>

# ZAB 协议 

---

## 介绍

ZAB（ZooKeeper Atomic Broadcast 原子广播） 协议是为分布式协调服务 ZooKeeper 专门设计的一种支持崩溃恢复的原子广播协议。 在 ZooKeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。

## ZAB 协议两种基本的模式：崩溃恢复和消息广播

ZAB 协议包括两种基本的模式，分别是 **崩溃恢复和消息广播**。当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进人恢复模式并选举产生新的 Leader 服务器。当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该 Leader 服务器完成了状态同步之后，ZAB 协议就会退出恢复模式。其中，**所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和 Leader 服务器的数据状态保持一致**。

**当集群中已经有过半的 Follower 服务器完成了和 Leader 服务器的状态同步，那么整个服务框架就可以进人消息广播模式了。** 当一台同样遵守 ZAB 协议的服务器启动后加人到集群中时，如果此时集群中已经存在一个 Leader 服务器在负责进行消息广播，那么新加人的服务器就会自觉地进人数据恢复模式：找到 Leader 所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。正如上文介绍中所说的，ZooKeeper 设计成只允许唯一的一个 Leader 服务器来进行事务请求的处理。Leader 服务器在接收到客户端的事务请求后，会生成对应的事务提案并发起一轮广播协议；而如果集群中的其他机器接收到客户端的事务请求，那么这些非 Leader 服务器会首先将这个事务请求转发给 Leader 服务器。

<br>

# ZooKeeper 特点

---

- **顺序一致性：** 从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。
- **原子性：** 所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。
- **单一系统映像 ：** 无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。
- **可靠性：** 一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。

